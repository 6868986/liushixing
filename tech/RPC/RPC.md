### RPC

#### RPC简介

​		RPC，Remote Procedure Call，远程过程调用，是一种编程模型。

​		解决分布式系统中服务之间的调用问题；

​		使远程调用像本地调用一样，调用者感知不到底层网络编程的细节，更加专注于业务逻辑。就像建在小河上的桥一样连接着河的两岸，如果没有小桥，我们需要通过划船、绕道等其他方式才能到达对面，但是有了小桥之后，我们就能像在路面上一样行走到达对面，并且跟在路面上行走的体验没有区别。

**RPC的使用**：通过maven将服务提供方暴露的接口依赖（jar包）导入到自己的pom中；当需要调用服务提供方暴露的接口时，只需要通过Ioc的方式将接口对象注入到spring容器中，然后就可以在本地直接调用接口的方法。

​		作为RD，追求的是一个**高性能高可用**的RPC框架。

#### RPC通信过程

<img src="https://upload-images.jianshu.io/upload_images/7143349-9e00bb104b9e3867.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img" style="zoom:150%;" />

Client端：

- Application是RPC的调用方；
- Client Stub相当于代理对象，也就是客户端的serviceImpl，其实内部是通过rpc方式来进行远程调用的代理对象proxy；
- Client Run-time Library，则是实现远程调用的工具包，比如jdk的Socket；
- Transport通过底层网络实现实现数据的传输。

这个过程中最重要的就是序列化和反序列化 => 数据传输的数据包必须是二进制的，将Java对象序列化为二进制格式传输

#### RPC&Restful

二者并不是一个维度的概念，RPC设计的范围更广。RPC是面向过程，Restful是面向方法。

#### RPC的实现

​		代理模式+Spring IoC：通过Spring注入serviceImpl对象，注入时，如果扫描到对象加了@Reference注解 => 注入+proxy，则会在工厂中生成一个代理对象。这个proxy的内部就是通过RPC进行远程调用的。

- 一个服务有多个实例，如何获取这些实例的地址socket => 注册中心
- 如何确定选择哪个实例 => 负载均衡策略
- 每次调用都需要去注册中心查实例列表效率低 => 缓存
- 客户端发起调用后继续处理自己的事 => 异步调用
- 服务端接口的版本控制
- 服务端接受调用的线程池
- ......

#### RPC demo

https://github.com/6868986/JavaDemo/tree/main/src/main/java/org/example/RPC/RPCdemo

缺点：

- 需要自己手动写proxy对象用来发起RPC调用很不方便

  思想：要求所有的远程调用都遵循一套模板。把远程调用的信息放到一个Request对象里面，发给Server端，Server端解析之后就知道要调用的是哪个RPC接口、以及入参的类型、入参的值。

  => 实现代理对象通用化 => 协议

- 集成spring

  通过spring的IOC来创建代理对象

  Dubbo：Dubbo通过和Spring的集成，在Spring容器初始化的时候，如果扫描到对象加了@Reference注解，那么就给这个对象生成一个代理对象，这个代理对象会负责远程通讯，然后将代理对象放进容器中。因此代码运行时用到的对象其实是spring工厂中的代理对象。

  http://dubbo.apache.org/books/dubbo-user-book/

  http://dubbo.apache.org/books/dubbo-dev-book/

- 长连接、短连接

  可以保持若干个长连接，然后每次有rpc请求时，把请求放到任务队列中，然后由线程池去消费执行；

  不能每次调用RPC接口时都去开启一个Socket建立连接；

- server线程池同时处理多个RPC请求

- 服务注册中心

- 负载均衡

- server结果缓存

- 版本控制

- 异步调用

- 优雅停机

#### Socket与网卡

#### RPC协议

- 为啥需要一套通信协议

  RPC远程调用过程中涉及到正反序列化以及解编码，且网络当中只能传输二进制的数据

  request => 转化为二进制数据 => 写入本地socket中 => 经网卡发送到网络 => TCP通道（数据包）

  client发送的二进制request数据会进入TCP数据包，可能一个request请求数据被拆分成好几个数据包，也可能合并其他的request请求数据；对于server端而言，从TCP通道中接收到的很多二进制数据，为了辨识出完整的request请求，因此需要一套协议来对数据进行分割。

  类比文章+标点

- 协议的设计

  想法：用一个固定长度（eg：4byte）保存整个request请求的大小，然后用一个可变长度保存request的数据

  => 消息头+消息体

  - 消息头
    1. 确定消息的边界
    2. 序列化方式
    3. 消息ID、类型
    4. 协议类型、版本
    5. ......
  - 消息体
    1. 请求的接口方法
    2. 请求的业务参数
    3. 请求的扩展属性

  存在的问题：定长的协议头导致不可扩展 => 协议头里面不能加新的参数

  **思考**：为啥新参数不能加在变长度的消息体里

  总结：协议头固定部分 + 协议头扩展部分 + 协议体

- RPC协议如何实现请求与响应关联的呢

#### 序列化

​		协议服务于序列化，任何序列化框架的核心都是设计一种序列化协议。把对象所属的类、属性、属性值等按照协议固定的格式写入到二进制的字节流中，完成序列化，再按照协议固定的格式将对象的这些属性从二进制流中读出，然后创建出一个新的对象，完成反序列化。

- 常见序列化协议

  1. JSON
  2. JDK原生序列化
  3. ......

- 衡量标准

  安全可靠 > 兼容通用 > 性能、效率、空间开销

- 

#### 网络IO模型（网络通信）

- 同步阻塞BIO（blocking IO  非高并发场景）

  Linux中默认所有的socket都是blocking的；

  类似珊珊去饭店吃饭的过程，点菜 => 等待服务员上菜 => 服务员把菜端到餐桌 => 珊珊吃宫保鸡丁/鱼香肉丝

  这个过程中，珊珊相当于OS中的用户线程，点菜的动作相当于发起一次IO请求，等待上菜即为用户线程阻塞，服务员上菜相当于内核把数据拷贝到用户内存空间，珊珊吃肉相当于用户线程拿到数据然后继续处理自己的任务。

  **内核在这个过程中需要做的是等待数据 + 拷贝数据。**

- 同步非阻塞NIO

- 异步非阻塞AIO

- IO多路复用（IO multiplexing  高并发场景）

  NIO、Redis、Nginx、Reactor模式（Java的Netty）

  多路：多个通路 => 多个网络IO

  复用：多个通路复用在一个复用器 => 一个线程处理多个IO请求

  相当于多个网络IO请求可以注册到一个“复用器”（select、poll、epoll），内核会监听所有“复用器”负责的socket，当任何一个socket的数据准备好了，调用就会返回，此时用户再进行read操作，将数据从内核拷到用户内存。

  类似a、b、c、d一起去餐厅吃饭，b、c、d分别点了自己爱吃的菜，然后a在餐馆等着，b、c、d出去玩，然后等菜上了，a再分别通知b、c、d，让他们回来吃。

***zero-copy***

***OS中的zero-copy***：

内核：

- 等待数据：等待网卡接受到数据，然后通过DMA拷贝到内核中
- 拷贝数据：将内核的数据拷贝到用户进程的内存空间中

应用进程的读写操作：

1. ​						

零拷贝 => 取消用户空间和内核空间之间的数据拷贝操作,从而提升CPU的利用率（专注计算而不是数据拷贝）。

目标：让用户进程向用户空间写入/读取数据，就像直接向内核空间写入/读取数据一样，然后再由DMA拷贝从而到达网卡

思想：用户和内核都将数据写到一个地方 => 虚拟内存

- mmap + write
- sendfile

***Netty中的zero-copy***

***Kafka中的zero-copy***

#### 动态代理

spring-aop：动态字节码增强，实现统一拦截效果。

**运行时生成代理类并绑定的逻辑**：RPC在***调用***注入到spring容器中的接口对象时，实际使用的是这个接口对象的代理对象proxy，在proxy中包含了实际的远程调用逻辑。

- JDK原生动态代理（存在局限性）：
- Javassist
- Byte Buddy

####  RPC整体架构

![image-20230529165042846](/Users/liushixing/Library/Application Support/typora-user-images/image-20230529165042846.png)

***思考***：咋做到可扩展，从而实现开闭原则？

#### 服务发现

- 啥是服务发现

  调用者拿到的是服务提供方暴露的接口，在prod环境中服务提供方都是以集群的方式对外提供服务，因此要维持一个接口和服务提供节点的IP映射，同时要完成对节点下线、服务扩容等场景的覆盖，也就是调用者能够及时感知到服务节点的变化。

- 基于zookeeper的服务发现（CP）

  源码：https://github.com/apache/zookeeper

  zookeeper学习沉淀：https://github.com/6868986/Test/blob/dev/RDstudy/DistributedSystem.md#zab%E7%AE%97%E6%B3%95

- 基于消息总线的注册中心（AP）

#### 负载均衡









































