#### HashMap

- 红黑树

  不是平衡二叉树（AVL)

  为啥用红黑树不用AVL、相对AVL的优势

  > 红黑树的 查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树， avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的 开销要小得多
  >
  > 
  >
  > 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！
  >
  > 
  >
  > 如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。

  **自平衡二叉查找树**

  性质1：每个节点要么是黑色，要么是红色。

  性质2：根节点是黑色。

  性质3：每个叶子节点（NIL）是黑色。（叶子是NIL节点）

  性质4：每个红色结点的两个子结点一定都是黑色。

  **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**

  - ***性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点***
  - 性质5.2：左子树和右子树的黑结点的层数是相等的  =>  **黑色完美平衡**

- 左旋、右旋、变色

  ***旋转操作***：一边子树的节点数比另一边多了/少了，因此需要送/借另一边

  **左旋**：左边节点过多，给右边点

  以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。

  ![img](https://upload-images.jianshu.io/upload_images/2392382-a95db442f1b47f8a.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

  **右旋**：右边节点过多，给左边点

  以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。

  ![img](https://upload-images.jianshu.io/upload_images/2392382-0676a8e2a12e2a0b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

  **变色**：结点的颜色由红变黑或由黑变红。

- 红黑树的插入（插入一个红节点 => 不影响黑色完美平衡）

  ***查找目标节点 && 插入***

  1. 空树：直接插入 && 黑色根节点

  2. 插入的key已存在：查找到该节点 && 更新值 && 颜色保持不变

  3. 插入位置的父节点为黑：直接插入红节点 => 不影响黑色完美平衡

  4. 插入位置的父节点为红：

     PP祖父节点、P父节点、S叔叔节点

     4.1：S存在 && S为红

     ​		根节点为黑 && P为红 => P不是root => PP存在 && 必为黑

     ​		=> 目前是黑红红 => 变色为红黑红

     ​		=> 若PP的父节点为黑，则结束插入

     ​		=> 若PP的父节点为红，则将PP作为新的插入节点（红色），重新对他的父节点&祖父节点进行变色（自平衡）

     ![img](https://upload-images.jianshu.io/upload_images/2392382-9f2c746bf0769f49.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

     ![img](https://upload-images.jianshu.io/upload_images/2392382-5374ea3c2956b441.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

     特殊情况：PP为root => PP需变色为黑色 => **唯一一种会增加红黑树黑色结点层数的插入情景**

     **红黑树的生长是自底向上的**，普通的二叉查找树的生长是自顶向下的

     4.2：（S不存在 || S为黑）&& **并且插入结点的父亲结点是祖父结点的左子结点**

     ​		4.2.1：**插入结点是其父结点的左子结点**

     ![img](https://upload-images.jianshu.io/upload_images/2392382-ab4097b750826870.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

     ​		4.2.2：**插入结点是其父结点的右子结点**

     ![img](https://upload-images.jianshu.io/upload_images/2392382-fbfc4f299941cb8b.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

     4.3：**叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点**

- 红黑树的删除

  二叉树删除结点找替代结点有3种情情景：

  - 情景1：若删除结点无子结点，直接删除

  - 情景2：若删除结点只有一个子结点，用子结点替换删除结点

  - 情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点

    情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：**把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点**。

  - ***删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！***

    链接：https://www.jianshu.com/p/e136ec79235c

- **线程安全的理解**

- 为什么每个线程都要有自己的工作内存？

  - 操作速度  线程的寄存器 >> 主内存
  - 

#### 线程安全

##### volatile

- 原理

  并发编程 && 多核机器环境下，不同线程跑在不同的CPU上，当操作（修改）共享变量时，

  JVM向CPU发一条LOCK前缀指令（相当于一个写内存屏障）

  线程1修改了共享变量a，由于写内存屏障的存在，下一步会将a写回主内存，

  此时由于缓存一致性协议的存在，会通知其他CPU将自己维护的缓存行置为无效状态，而后再过来读请求的时候再重新去主存读最新的a

  CPU => CPU Cache => 缓存一致性协议 => 主内存

  - ***指令重排序***：

    ```
    Instance instance = new Instance();
    ```

    1. 为instance分配内存空间
    2. 初始化instance（内存地址写入值）
    3. instance指向为其分配的内存空间

    JVM将指令重排为1 -> 3 -> 2，单线程下没有问题，多线程情况下会导致返回未初始化的实例对象

- 使用场景

  1）对变量的写操作不依赖于当前值

  2）该变量没有包含在具有其他变量的不变式中

  => 保证操作原子性

  

##### synchronize

***本质都是对对象监视器 monitor 的获取***

执行monitorenter指令加锁 =>

CAS修改markword中的锁标志位

锁升级 => ***为了提高获得锁和释放锁的效率***

- 无锁

- 偏向锁

  单线程a （自己维护一个属于自己的栈资源）

  a每获取一次锁，都会将LR（LockRecord）压栈，同时将markword拷贝到LR中；

  每释放一次锁，都会LR出栈

  对于锁（对象）本身而言，它的markword中的指针同时也会指向当前持有锁的线程的LR

- 轻量级锁：另一个线程CAS自旋

- 重量级锁

  如果当前线程自旋一段时间后没有抢到锁就会升级成重量级锁  => 不能一直自旋（CPU爆满）

  并将当前的线程存入EntryList队列中阻塞，持有锁的线程执行完成后，在唤醒EntryList队列中的线程去抢占锁

非公平锁获取不到的话，线程进入 => wait()状态

##### Lock

- AQS

  - volatile修饰的state

  - CAS问题

    - 长时间自旋开销大：轻量级锁 ------> 重量级锁

    - 只能保证对一个共享变量的操作

  - AQS节点

- 高级锁功能

- 并发容器

  - ReentrantLock

    可重入锁

  - Semaphore

    控制访问共享资源的最多线程数

    通过CAS来修改state的值，未获取到的线程会进入阻塞队列，然后被挂起

  - CountDownLatch

    将count个线程阻塞到一个地方，等待其他线程

    只能使用一次（count只能初始化一次）

  - CycliBarrier

    基于ReentrantLock & Condition实现的

##### ThreadLocal

- 内部类ThreadLocalMap，类似HashMap，但没有链表结构；key为对ThreadLocal对象的弱引用，value为ThreadLocal的值；一个线程对应一个ThreadLocalMap，一个ThreadLocalMap里面存储很多ThreadLocal变量

- ![img](https://javaguide.cn/assets/5.deed12c8.png)

- 采用的hash算法 => 自增hash

  每创建一个ThreadLocal对象，都会增加0x61c88647（黄金分割数/斐波那契数）=> 使得hash分布非常均匀

- ThreadLocalMap的set()方法（insert/update）

  根据hash算法求出对应的位置索引index，该位置上的Entry

  1. Entry为null => 直接加

  2. Entry的key与set()的key相同 => 直接数据覆盖

  3. hash冲突

     - 向后遍历先遇到null/遇到key相同的Entry => 直接插入

     - 向后遍历先遇到key过期的Entry => 执行替换过期数据的逻辑，进行探测式数据清理工作                                                                          先向前遍历，不断更新探测清理过期数据的下标x，直至扫到为null的Entry                                                                                                 再向后遍历，分为两种情况：

       1. 遇到key相同的Entry，更新值，并将其放到原来的index位置
       2. 没遇到，直至为null，创建新的Entry(key,value),插入到原来的index位置

       然后从更新后的x开始，向后遍历，进行回收工作

       > 核心思想：找到可用的bucket
       >
       > 可用：1.key相同（替换操作）
       >
       > ​			2.Entry为null
       >
       > ​			3.Entry过期，执行替换逻辑，占用过期桶

  4. 

- 

##### 线程池

#### 异常

#### CMS

- GC Roots对象

  java虚拟机栈、本地方法栈、常量对象、静态对象

- 重新标记阶段

  误标、漏标




hashmap为啥线程不安全   JDK1.7 &&  JDK1.8		哈希冲突后为啥>8才变为红黑树，为啥临界值是8

- JDK1.7  环形链表&&数据丢失问题

  多线程扩容hashmap过程中，线程1扩容到一半后被挂起，线程2开始执行并完成扩容，而后线程1执行，对已经扩容好的hashmap进行继续刚才的扩容操作

  发生哈希冲突的结点互相指向 && 某些结点丢失

  头插法导致数据倒序排列

- JDK1.8  数据覆盖问题

  多线程put过程中，向同一个空的bucket插入元素，线程1判断完没有哈希冲突后、准备直接插入前被挂起，线程2开始执行并成功插入该bucket的头结点，然后线程1继续执行，由于已经判断过了不存在哈希冲突，因此选择直接插入，从而会覆盖掉线程2的数据

- 哈希冲突

  发生哈希冲突，判断key是否一样

  一样，则直接覆盖

  不一样，则拉链法解决冲突

- **如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。**

- IOC/DI、AOP的理解 、循环注入        为啥要**解耦**，与new的区别

- 面向对象、相对于面向过程的优点

  - 可重用
  - 封装 => 安全性
  - 继承、多态 => 易扩展，子类在父类的基础上可以拥有自己的属性和行为
  - 结构清晰，与现实世界更为接近

- static可以修饰什么

  - 方法、变量

  - 静态代码块 => 仅在类加载时执行一次，先执行父类的静态代码块

    父类静态代码块  >  子类静态代码块 >  普通代码块  >  构造函数

  - 静态内部类

  - 作用：1.方便在我们没有创建对象时，调用类中的方法/变量

  ​			       2.static可以用来修饰类的成员方法、成员变量或编写static代码块，能够有效地优化程序性能

- SpringBoot常用注解

- ArrayList尾部空间开销，与LinkedList的不同

- 线程池的队列