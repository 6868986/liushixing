## 什么是TCP

TCP是面向连接的、可靠的、基于字节流的传输层协议

## 什么是TCP连接

用于保证可靠性 和 流量控制  而维护的一些状态信息，这些信息的组合，包括socket、序列号（seq）、窗口大小，称为连接。

## 三次握手

1. SYN + (seq = x)
2. SYN + ACK + (seq = y) + (ack = x + 1)
3. ACK + (ack = y + 1)
4. TCP建立连接时，**客户端和服务端各自生成自己的ISN**

## 为什么是三次握手，而不是两次、四次

三次握手才能够初始化TCP连接的状态信息（socket、seq、窗口大小）

1. ***防止初始化历史SYN连接***（情景：client端发完SYN后网络阻塞且client挂掉）

2. 实现可靠的初始化序列号isn同步（c端序列号+s端ack && s端序列号+c端ack）

3. 避免资源浪费（两次握手s端每收到一个SYN报文都会建立一个TCP连接=>生成多个冗余的无效连接）

   ### seq序列号作用

   1. 去重
   2. 按序接收
   3. 可以标识发出去的数据包中，哪些是已经被对方接收到的（通过ACK报文中的序列号）

## 每次建立TCP连接都要求不同的初始序列号ISN  [***time_wait***]

防止历史报文被下一个相同四元组的连接接收。

历史报文序列号落入接收窗口的概率减小。

## MSS与MTU、IP层分片为何TCP层仍需按MSS分片

MSS + TCP头 + IP头 = MTU

数据包丢失重传问题

一个IP分片丢失，需要重传整个IP报文的所有分片

避免重传整个TCP数据包（TCP头+数据）

建立TCP连接时协商MSS的值

## 第一、二、三次握手丢失

1. 客户端重传SYN

2. 客户端重传SYN + 服务端重传SYN + ACK

3. 服务端重传SYN + ACK （第三次握手的ACK报文不会重传）

   最大重传次数 + 1 = 发送次数

   重传时间RTO逐次递增（1 + 2 + 4 + 8 + 16 <= 最大重传次数为5）

   达到最大重传次数后再等待  2 * 上次重传等待时间  后不再重传，进入CLOSED状态

## SYN攻击

半连接队列（SYN队列） 

全连接队列（accept队列）

SYN攻击会将半连接队列打满，后续收到的SYN报文会丢掉

## 四次挥手

双方都可以主动断开连接，主动FIN的一端才会进入time_wait状态，另一端closed_wait状态

发送FIN报文表示我不需要发送数据了，但是还可以接收数据

1. A端发送FIN报文（标志位FIN = 1），进入FIN_WAIT_1状态
2. B端收到后向A发送ACK报文，进入close_wait状态
3. A端收到ACK报文进入FIN_WAIT_2状态
4. B端处理完数据后，向A端发送FIN报文，进入LAST_ACK状态
5. A端收到后向B端发送ACK，进入time_wait状态
6. B端收到ACK后进入closed状态
7. A端等待2MSL后自动进入closed状态

## 第一、二、三、四次挥手丢失

调用close()函数关闭连接：不再发送和接收 => FIN_WAIT_2状态不会维持太久，超过60s（默认值）未收到第三次挥手（服务端的FIN报文）直接进入CLOSED状态

调用shutdown()函数关闭连接：不再发送但可以接收 =>FIN_WAIT_2会一直等待

第四次挥手丢失：服务端会重传FIN报文，客户端每次收到重传的FIN报文都会重置time_wait，重新等待一个新的2MSL

## close_wait、time_wait

close_wait：等待应用进程调用close()函数并向客户端发送FIN报文

​					服务端收到FIN报文并不会立即关闭socket，所以先回给客户端一个ACK报文

​					等服务端发送完全部数据报文，才会向客户端发送FIN报文

time_wait ： 

1. **2MSL**

- MSL：报文最大生存时间
- TTL：IP协议中报文最多可以经过的路由器数量，在IP头中
- MSL >= TTL降为0所消耗的时间
- 保证A发送的最后一个ACK报文能够到达B（**至少允许报文丢失一次**，连续两次丢包的概率很小）

​	2. 为何需要time_wait

- 防止历史连接中的报文数据，被后面相同四元组的连接接收

  序列号seq（32位unsigned）与初始序列号isn（32位计数器）都不是无限递增的，都会回绕为初始值

  => 无法根据seq&isn来判断新老数据

  若无time_wait或者过短 

  => 相同端口号的TCP连接被重用后[**相同四元组重新打开新连接**]，老数据包由于网络阻塞，现在才到达，但其序列号刚好落在接收窗口中，接收后导致数据错乱

  **2MSL足以使两个方向上的数据包都被丢弃，原来连接产生的数据包在网络中自然消失，再出现的数据包一定是在新的连接上产生的**

- 确保被动关闭连接的一方能够正确被关闭（最后一次ACK能被接收）								

 3. time_wait状态过多导致的问题

    占用系统资源

    占用端口资源

    - 客户端  端口被占满则无法与[目的IP+目的PORT]一样的服务端建立连接了

      ​				但是如果连接不同的服务端，则端口可以重复使用

      ​				原因：内核通过四元组定位TCP连接[源IP + 源PORT + 目的IP + 目的PORT]

    - 服务端  只监听一个端口，不会导致端口资源受限，但会导致系统资源受限

## 重传机制

1. 超时重传

   RTT 往返时延

   RTO 重传时间间隔

   RTO应略大于RTT [过大/过小的问题]

   重传时间间隔倍增   <=   连续重传说明网络环境差，不宜频繁发送

## 滑动窗口

1. 为何引入？

   ack的存在

   往返时间越长，通信效率越低，网络吞吐量越低

   某条ACK包丢失，只要收到下一条ACK，则数据已经到达

2. 窗口大小

   TCP头中的Windows

   接收方告诉发送方自己还有多少缓冲区能接收数据

3. 发送端的滑动窗口

   1.已发送且ack

   2.**已发送且未ack**

   3.**可发送（在接收方处理范围内）**

   4.不可发送

   2&3组成发送窗口

   - 三个指针：指向2、3的第一个字节（两个绝对指针）

     ​					相对指针 # 指向4的第一个字节 2 + 发送窗口大小

4. 接收方的滑动窗口

   1.收到且已ack（等待应用进程读取）

   2.未收到且可以接收

   3.未收到且不可接收

   两个指针：指向2的第一个字节（绝对）

   ​					*2 + 接收窗口大小

接收窗口不事实等于发送窗口，通过TCP头中的Windows传递

## 流量控制

1. 操作系统缓冲区 => 滑动窗口

   TCP不允许同时减少缓冲区又缩窗口  =>  丢包

   先缩窗口，过段时间再减缓存

2. 窗口关闭

   => 潜在的死锁现象 =>  B端处理完数据后，窗口恢复非0，向A端发送窗口非0的ACK报文，如果这条报文丢失，则进入死锁状态

   解决：A端、收到窗口为0的ACK报文后，启动持续计时器；如果超时则向B发送窗口探测报文，B收到后向A回复带着窗口大小的ACK

   => 若接收窗口仍为0，则A端重启持续计时器；若不为零，则打破死锁

## 拥塞控制

1. 发送窗口swnd = Math.min(拥塞窗口cwnd,接收窗口rwnd)
2. 如何判断网络出现拥塞
3. 慢启动 => 拥塞避免算法 => 拥塞发生 => 快速恢复
   - **初始化cwnd = 1**，每收到一个ACK，cwnd + 1；指数性增长至ssthresh
   - 每收到一个ACK，cwnd增加1 / cwnd；线性增长
   - 出现数据包重传 => 网络拥塞
   - 超时重传 ：ssthresh = cwnd / 2；cwnd 变为初始值（1）
   - 快速重传：cwnd = cwnd/2；ssthresh = cwnd    +    快速恢复

## TCP面向字节流

UDP：一条用户消息 => 一个UDP报文

TCP ： 一条用户消息 => 一个/多个TCP报文

粘包：两条消息的部分内容被分到一个TCP包中，接收方不知道消息的边界

- 固定长度的消息
- 特殊字符作边界  http使用回车符和换行符作为边界，消息中含有 => 转义
- 自定义消息结构

#### TCP报文首部格式

- 源端口号、目的端口号

  ***端口***：确认目标主机上的哪个应用程序（进程）

- 序列号、确认序列号

- 窗口大小（流量&&拥塞）、标志位（SYN、FIN、ACK、RST）

- 

## SYN报文丢弃

1. SYN队列满了
   - 开启syncookies功能   syncookies = 1 => SYN队列满了也不会丢掉SYN报文
   - 增大SYN对列和accept队列
   - 减少SYN+ACK报文的重传次数，更快的断开处于SYN_RECV状态的TCP连接
2. accept队列满了

## TCP、UDP可以绑定同一个端口

1. tcp调用socket后先bind端口，而后listen端口；udp之后bind

## HTTP

#### 超文本传输协议

#### 状态码

- 1** 中间状态
- 2** ok
- 3** 请求资源重定向（新的URL）
- 4** 客户端请求报文错误
- 5** 服务端内部错误

#### 常见字段

> HTTP 基于 TCP  => TCP粘包问题
>
> 请求行 && http header => 回车符、换行符作为边界
>
> http body => Content-length 作为边界

connection：keep - alive 开启http长连接

#### GET & POST

- GET ：从服务器上获取指定的资源  参数在URL中
- POST ：根据http-body对指定的资源做出处理，数据在http - body中
- GET => 只读操作 安全且幂等 => 可以浏览器缓存
- POST => 新增或提交数据  对资源做出修改 => 不安全&不幂等

但是GET也可以增删改，POST也可以查

#### HTTP缓存技术

#### URL => 页面显示

1. 解析URL，生成HTTP请求

   解析URL是为了确定要请求的Web服务器和文件路径

2. 将Web服务器域名解析为真实IP地址【一个网络中的一台主机上的一个网卡对应一个IP】（www.server.com）

   - 浏览器缓存
   - 操作系统缓存
   - hosts文件
   - 本地DNS服务器缓存
   - 根域名DNS服务器（.）
   - 顶级DNS服务器（.com）
   - 权威DNS服务器（server.com）

   DNS服务器：保存Web服务器域名和IP的映射

   解析出Web服务器的IP地址后，client便可以与server建立连接了

   通过调用socket，将目标IP发到操作系统的协议栈中，而后才会有TCP、IP

3. 网卡发送数据包

   网卡驱动程序获取到二进制的网络包后，将其复制到网卡内的缓存区内，加头尾，最后将网络包转为电信号，通过网线发出去

#### HTTP & HTTPS

- 区别

  1. http明文传输，https加入了SSL/TLS安全协议，能够加密传输报文
  2. 默认端口http：80，https：443
  3. https需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

- https解决了http的哪些问题

  1. http存在风险

     - 窃听
     - 篡改
     - 冒充

  2. https如何解决

     - 混合加密
       1. client
     - 摘要算法【完整性保护】
     - 数字证书【认证】

     

- 

## NetWork

- 应用层：为用户实现功能
- 传输层：服务应用层
- 网络层：IP协议——寻址 & 路由
- 数据链路层
- 物理层



























