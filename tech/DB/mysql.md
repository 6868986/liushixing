# MySQL

## 索引

1. 建立/不建立索引的场景？如何优化索引？

   - 建立索引

     1. 经常用于where查询的字段
     2. 经常用于连接、排序的字段
     3. 区分度大的字段

   - 不建立索引

     1. where子句中不用的
     2. 经常修改的字段
     3. 数据量较小的时候
     4. 区分度低的字段

   - 索引优化

     1. 使用覆盖索引，避免回表

     2. 使用前缀索引，防止索引过大【短索引】

     3. 主键索引自增，防止***页分裂***

     4. 索引列NOT NULL

     5. 防止索引失效

        失效场景：

        - 组合索引与最左匹配
        - 索引列参与计算
        - 索引列参与OR条件
        - 模糊查询like %index
        - 隐式数据类型转换

2. B+ TREE

   - 数据结构【查询过程】

   - 优点

     1. ***InnoDB的B+ TREE中一个节点是一个页；***

        ***非叶子结点只存索引和指向下一层节点的指针【页号】，不存数据，因此一个节点可以存放更多索引；***

        ***索引越多，子节点就越多，从而阶数更大；***

        ***阶数大代表一层能够存放的数据多，从而层数少；***

        ***查询数据时，每层只需要取出一个节点（页），一层代表一次IO，层数少代表IO次数少。***

     2. 叶子结点之间的双向链表方便范围查询
     
     3. 根节点到叶子结点固定的IO次数，效率稳定

3. 索引分类

   - 按数据结构

     1. B+ TREE
     2. Hash

   - 按物理存储

     1. 聚集索引

        InnoDB：primary key -> 第一个不允许为null的unique key -> 隐式自增ID

     2. 非聚集索引（二级索引/辅助索引）

   - 按字段特性

     1. 主键索引
     
     2. 唯一索引
     
     3. 组合索引【子段个数】
     
        例如：对（a,b,c）建立索引，如下两个where条件语句都会走索引【查询优化器】
     
        1. where a=1 and b=2 and c=3；
        2. where b=1 and a=2 ；
     
        但是：
     
        1. a：where a > 1 and b = 2；
        2. a、b：where a ***>=*** 1 and b = 2；where a ***between*** 2 and 8 and b = 2
        3. name、age：where name ***like*** 'j%' and age = 22
     
     4. 全文索引（前缀索引）

4. IO

   - 存储引擎与磁盘的IO

     1. 单位：数据页

        InnoDB中的数据以数据页为单位与磁盘进行IO，数据页默认大小为16KB

        数据页的FileHeader里面有prev、next指针，使数据页可以连接成一个双向链表【逻辑顺序】

        数据页中的数据检索依赖页目录；页中存储着有限的数据行记录，且主键有序，将数据记录进行分组，得到有序的组号【槽号】放置在页目录中，而后依据槽号进行二分查找

        组号：每组的第一个主键（最小的）

   - 磁盘的数据组织方式

     1. 单位：数据页
     2. 物理地址不连续，通过prev、next指针实现逻辑连续

## 日志

1. Redo Log

   物理日志，记录的是“对某数据页做了某修改”，Innodb存储引擎独有  => MySQL数据恢复

   - MySQL的数据以页为单位进行存储，对一条记录进行操作的过程是：从磁盘中读取记录所在的页，加载到BufferPool中，叫做数据页，后续会先到BufferPool中去查询，没命中再去磁盘

   - 事务中包含对数据的修改操作（修改的是BufferPool），修改成功后会将更新信息记录到RedoLog的缓冲区，根据刷盘时机，刷新到磁盘中的RedoLog文件

     同时buffer pool中被修改的数据所在的数据页会被标记为**脏页**

   - 刷盘时机

     刷盘：将redo log buffer中的记录写入到***page cache文件系统缓存***，然后调用fsync同步到磁盘

     1. 事务提交时（Innodb引擎为RedoLog规定的默认刷盘策略参数为1）
     2. 后台线程每隔1s刷盘一次
     3. 当 `redo log buffer` 占用的空间即将达到 `innodb_log_buffer_size` 一半的时候，后台线程会主动刷盘

   - 日志文件组 => Redo Log在磁盘上的组织形式（环形数组）

     - **write pos** 是当前记录的位置，一边写一边后移
     - **checkpoint** 是当前要擦除的位置，也是往后推移

   - ***为何不对数据页刷盘而是选择对数据页的更改信息刷盘***

     实际上，数据页大小是`16KB`，刷盘比较耗时，可能就修改了数据页里的几 `Byte` 数据，有必要把完整的数据页刷盘吗？

     而且数据页刷盘是***随机写***，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。

     如果是写 `redo log`，一行记录可能就占几十 `Byte`，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是***顺序写***，所以刷盘速度很快。

     所以用 `redo log` 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。

2. Bin Log

   MySQL数据库的**数据备份、主备、主主、主从**，都需要依靠binlog同步数据，保证了MySQL集群的数据一致性

   - 记录格式

     1. statement  =>  sql语句
     2. row
     3. mixed

   - 写入机制

     一个事务的binlog不能被拆开，必须一次写入，因此为每个线程分配一个binlog cache；

     事务执行过程中会将修改记录到binlog cache中，事务提交时将binlog cache写到磁盘

     write：binlog cache ===>  文件系统缓冲page cache

     fsync：page cache ===>  磁盘

     刷盘时机参数：0             1              N

   - ***两阶段提交***

     redolog分为prepare阶段和commit阶段

     prepare阶段为写入redolog但不刷盘

     commit阶段为事务提交 && binlog成功提交后，redolog提交

3. Undo Log

   InnoDB生成的回滚日志，保证事务原子性，在数据修改前写undolog

   - 通过事务id和回滚指针来记录undo log，完成事务的回滚

   - 与ReadView共同完成MVCC【多版本并发控制】

   - 持久化机制：刷盘

     与数据页相同，都需要记录redolog；buffer pool除了数据页，还有undo页

   - 更新时机：

     当有修改请求打入时，在修改buffer pool中的数据行前，先把原来的记录生成一条undo log并写入buffer pool中的Undo页

4. **WAL**

   Write ahead log 预写日志，用于保证事务的原子性【回滚】和持久性【刷盘】

   - 原理：修改不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；如果事务失败，WAL 中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改
   - 优点：
     1. 读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）
     2. WAL 在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件
     3. 磁盘 I/O 行为更容易被预测
     4. 使用更少的 fsync()操作，减少系统脆弱的问题
   - MySQL中的Redolog就属于WAL技术，将随机写转换成了顺序写
     1. 修改请求打到InnoDB存储引擎
     2. 写redolog buffer，写数据行所在的数据页页
     3. redolog刷盘
     4. 根据redolog将数据落盘

5. **buffer pool**

   磁盘与内存交互的缓冲池；加速更新【WAL】&&加速查询

   - buffer pool中存放了数据页、索引页、Undo页、锁信息等

   - buffer pool又可以分为未使用、干净页、脏页，其中脏页需要定期刷盘，实现事务的持久性

   - 内存淘汰机制：冷热LRU

     **冷热LRU算法**执行流程：

     初始数据页LRU链：x1 -> x2 -> x3 -> x4 -> x5 -> x6 -> x7 -> x8 -> x9

     其中x1-x5是热链，x6-x9是冷链

     1. 要访问数据页x3，由于x3在热链区域，因此和优化前的LRU算法一样，将其移到链表头部，变成下图。→ young区域遵循普通LRU

        **x3** -> x1 -> x2 -> x4 -> x5 -> x6 -> x7 -> x8 -> x9

     2. 之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉尾部数据页x9，但是新插入的数据页x10，是放在x6处，如下。→ 新数据放入冷链头部

        x3 -> x1 -> x2 -> x4 -> x5 -> **x10** -> x6 -> x7 -> x8

     3. 处于冷链区域的数据页，每次被访问的时候都要做下面这个判断：

        - 若这个数据页在LRU链表中被访问的时间超过了1秒，就把它移动到链表头部（热链区域的头）；
        - 如果这个数据页在LRU链表中被访问的时间短于1秒，位置保持不变。1秒这个时间，是由参数innodb_old_blocks_time控制的。其默认值是1000，单位毫秒。

     这个机制是为了处理类似全表扫描的操作而设计的。

     1. 扫描过程中，需要新插入的数据页，都被放到冷链区域
     2. 一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过1秒，因此还是会被保留在冷链区域
     3. 继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部（也就是热链区域），很快就会被淘汰出去。

     可以看到，这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了Buffer Pool，但是对young区域完全没有影响，从而保证了Buffer Pool响应正常业务的查询命中率。

6. **脏页刷盘**

   - redolog写满了

     writepos和checkpoint重合了，这时系统需要停止所有更新操作，而后将oldCheckpoint向前推至newCheckpoint，此时要确保oldCheckpoint与newCheckpoint之间的脏页都被刷到磁盘上

   - 系统内存满了

     一次查询未命中buffer pool中的数据页，此时需要向缓冲池申请一个页，用来存放从磁盘中新取出来的包含要查询的数据行的数据页；

     1. 如果buffer pool中还有未使用的页，那就直接申请；

     2. 如果buffer pool中的页都是干净页和脏页，这时就需要通过LRU淘汰

        - 如果淘汰的是干净页，则直接释放

        - 如果淘汰的是脏页，就必须将脏页刷盘；此时如果本次查询要淘汰的脏页过多，就会导致查询时间拉长

        - 问题：此时能不能直接把脏页内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿redo log出来改好数据？ 

          这样会导致整体性能降低。如果淘汰脏页一定会写盘，就保证了每个数据页有两种状态： 一种是内存里存在，内存里就肯定是正确的结果，直接返回； 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。 所以这种效率是最高的

     

   - mysql正常关闭

     此时会将buffer pool中的脏页全部刷盘，下次启动时直接读磁盘，而不需要再借助redolog

7. 

​			

## MySQL优化

1. 业务层面=>淘宝双十一的提前30天预售

2. 系统架构层面

   - redis缓存
   - 数据库连接池
   - 分库分表  横向：根据一些字段值，例如时间范围；纵向：根据业务，例如订单信息与商品信息，新订单与续订订单
   - 读写分离、负载均衡   MySQL主从

3. 代码层面

   - 产生锁竞争的语句放在后面执行
   - 长事务拆成多个小事务   长事务：mvcc经常回滚查、长时间大量的占用锁资源，导致别的事务长时间阻塞、执行失败的话回滚困难

4. 表设计

   - 适当增加冗余字段
   - 主键自增ID
   - 字段非空限制

5. sql

   - 避免命不中索引

     场景

     - 组合索引&前缀匹配
     - or 前后条件必须都是索引列
     - 索引列不能放在表达式中
     - 模糊查询中，%在前的话走不了索引
     - String不加引号可能发生隐式类型转换
     - select *

6. 慢查询 => explain分析执行计划

7. 数据库参数

   - 增大bufferpool
