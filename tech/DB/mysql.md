# MySQL

## 索引

1. 建立/不建立索引的场景？如何优化索引？

   - 建立索引

     1. 经常用于where查询的字段
     2. 经常用于连接、排序的字段
     3. 区分度大的字段

   - 不建立索引

     1. where子句中不用的
     2. 经常修改的字段
     3. 数据量较小的时候
     4. 区分度低的字段

   - 索引优化

     1. 使用覆盖索引，避免回表

     2. 使用前缀索引，防止索引过大【短索引】

     3. 主键索引自增，防止***页分裂***

     4. 索引列NOT NULL

     5. 防止索引失效

        失效场景：

        - 组合索引与最左匹配
        - 索引列参与计算
        - 索引列参与OR条件
        - 模糊查询like %index
        - 隐式数据类型转换

2. B+ TREE

   - 数据结构【查询过程】

   - 优点

     1. ***InnoDB的B+ TREE中一个节点是一个页；***

        ***非叶子结点只存索引和指向下一层节点的指针【页号】，不存数据，因此一个节点可以存放更多索引；***

        ***索引越多，子节点就越多，从而阶数更大；***

        ***阶数大代表一层能够存放的数据多，从而层数少；***

        ***查询数据时，每层只需要取出一个节点（页），一层代表一次IO，层数少代表IO次数少。***

     2. 叶子结点之间的双向链表方便范围查询
     
     3. 根节点到叶子结点固定的IO次数，效率稳定

3. 索引分类

   - 按数据结构

     1. B+ TREE
     2. Hash

   - 按物理存储

     1. 聚集索引

        InnoDB：primary key -> 第一个不允许为null的unique key -> 隐式自增ID

     2. 非聚集索引（二级索引/辅助索引）

   - 按字段特性

     1. 主键索引
     
     2. 唯一索引
     
     3. 组合索引【子段个数】
     
        例如：对（a,b,c）建立索引，如下两个where条件语句都会走索引【查询优化器】
     
        1. where a=1 and b=2 and c=3；
        2. where b=1 and a=2 ；
     
        但是：
     
        1. a：where a > 1 and b = 2；
        2. a、b：where a ***>=*** 1 and b = 2；where a ***between*** 2 and 8 and b = 2
        3. name、age：where name ***like*** 'j%' and age = 22
     
     4. 全文索引（前缀索引）

4. IO

   - 存储引擎与磁盘的IO

     1. 单位：数据页

        InnoDB中的数据以数据页为单位与磁盘进行IO，数据页默认大小为16KB

        数据页的FileHeader里面有prev、next指针，使数据页可以连接成一个双向链表【逻辑顺序】

        数据页中的数据检索依赖页目录；页中存储着有限的数据行记录，且主键有序，将数据记录进行分组，得到有序的组号【槽号】放置在页目录中，而后依据槽号进行二分查找

        组号：每组的第一个主键（最小的）

   - 磁盘的数据组织方式

     1. 单位：数据页
     2. 物理地址不连续，通过prev、next指针实现逻辑连续

## 日志

1. Redo Log

   物理日志，记录的是“对某数据页做了某修改”，Innodb存储引擎独有  => MySQL数据恢复

   - MySQL的数据以页为单位进行存储，对一条记录进行操作的过程是：从磁盘中读取记录所在的页，加载到BufferPool中，叫做数据页，后续会先到BufferPool中去查询，没命中再去磁盘

   - 事务中包含对数据的修改操作（修改的是BufferPool），修改成功后会将更新信息记录到RedoLog的缓冲区，根据刷盘时机，刷新到磁盘中的RedoLog文件

     同时buffer pool中被修改的数据所在的数据页会被标记为**脏页**

   - 刷盘时机

     刷盘：将redo log buffer中的记录写入到***page cache文件系统缓存***，然后调用fsync同步到磁盘

     1. 事务提交时（Innodb引擎为RedoLog规定的默认刷盘策略参数为1）
     2. 后台线程每隔1s刷盘一次
     3. 当 `redo log buffer` 占用的空间即将达到 `innodb_log_buffer_size` 一半的时候，后台线程会主动刷盘

   - 日志文件组 => Redo Log在磁盘上的组织形式（环形数组）

     - **write pos** 是当前记录的位置，一边写一边后移
     - **checkpoint** 是当前要擦除的位置，也是往后推移

   - ***为何不对数据页刷盘而是选择对数据页的更改信息刷盘***

     实际上，数据页大小是`16KB`，刷盘比较耗时，可能就修改了数据页里的几 `Byte` 数据，有必要把完整的数据页刷盘吗？

     而且数据页刷盘是***随机写***，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。

     如果是写 `redo log`，一行记录可能就占几十 `Byte`，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是***顺序写***，所以刷盘速度很快。

     所以用 `redo log` 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。

2. Bin Log

   `MySQL`数据库的**数据备份、主备、主主、主从**，都需要依靠`binlog`同步数据，保证了MySQL集群的数据一致性

   - 记录格式

     1. statement  =>  sql语句
     2. row
     3. mixed

   - 写入机制

     一个事务的binlog不能被拆开，必须一次写入，因此为每个线程分配一个binlog cache；

     事务执行过程中会将修改记录到binlog cache中，事务提交时将binlog cache写到磁盘

     write：binlog cache ===>  文件系统缓冲page cache

     fsync：page cache ===>  磁盘

     刷盘时机参数：0             1              N

   - ***两阶段提交***

     redolog分为prepare阶段和commit阶段

     prepare阶段为写入redolog但不刷盘

     commit阶段为事务提交 && binlog成功提交后，redolog提交

3. Undo Log

   InnoDB生成的回滚日志，保证事务原子性，在数据修改前写undolog

   - 通过事务id和回滚指针来记录undo log，完成事务的回滚

   - 与ReadView共同完成MVCC【多版本并发控制】

   - 持久化机制：刷盘

     与数据页相同，都需要记录redolog；buffer pool除了数据页，还有undo页

   - 更新时机：

     当有修改请求打入时，在修改buffer pool中的数据行前，先把原来的记录生成一条undo log并写入buffer pool中的Undo页

4. buffer pool

   磁盘与内存交互的缓冲池

   - buffer pool中存放了数据页、索引页、Undo页、锁信息等
   - 

## MySQL优化

1. 业务层面=>淘宝双十一的提前30天预售

2. 系统架构层面

   - redis缓存
   - 数据库连接池
   - 分库分表  横向：根据一些字段值，例如时间范围；纵向：根据业务，例如订单信息与商品信息，新订单与续订订单
   - 读写分离、负载均衡   MySQL主从

3. 代码层面

   - 产生锁竞争的语句放在后面执行
   - 长事务拆成多个小事务   长事务：mvcc经常回滚查、长时间大量的占用锁资源，导致别的事务长时间阻塞、执行失败的话回滚困难

4. 表设计

   - 适当增加冗余字段
   - 主键自增ID
   - 字段非空限制

5. sql

   - 避免命不中索引

     场景

     - 组合索引&前缀匹配
     - or 前后条件必须都是索引列
     - 索引列不能放在表达式中
     - 模糊查询中，%在前的话走不了索引
     - String不加引号可能发生隐式类型转换
     - select *

6. 慢查询 => explain分析执行计划

7. 数据库参数

   - 增大bufferpool
